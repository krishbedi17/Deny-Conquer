===== src/network/MessageToSend.java =====
package network;

import java.awt.*;
import java.io.Serializable;

public class MessageToSend implements Serializable {
    int row, col;
    Point pixel;
    Color playerColor;
    String type;
    String senderID;

    public MessageToSend(int row, int col, Point pixel, Color playerColor, String type, String senderID) {
        this.row = row;
        this.col = col;
        this.pixel = pixel;
        this.playerColor = playerColor;
        this.type = type;
        this.senderID = senderID;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public int getRow() {
        return row;
    }

    public void setRow(int row) {
        this.row = row;
    }

    public int getCol() {
        return col;
    }

    public void setCol(int col) {
        this.col = col;
    }

    public Point getPixel() {
        return pixel;
    }

    public void setPixel(Point pixel) {
        this.pixel = pixel;
    }

    public Color getPlayerColor() {
        return playerColor;
    }

    public void setPlayerColor(Color playerColor) {
        this.playerColor = playerColor;
    }

    public void setSenderID(String senderID) {
        this.senderID = senderID;
    }

    public String getSenderID() {
        return senderID;
    }
}


===== src/network/Client.java =====
package network;
import game.Cell;
import game.GamePanel;

import javax.swing.*;
import java.io.*;
import java.net.Socket;
import java.util.UUID;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class Client {
    private Socket socket;
    private ObjectOutputStream out;
    private ObjectInputStream in;
    private String clientID;
    GamePanel panel;

    private final Object lockWaiter = new Object();
    private volatile boolean lockGranted = false;
    public Client(GamePanel panel) throws IOException {
        this.panel = panel;
        this.socket = new Socket("127.0.0.1", 53333);
        this.clientID = UUID.randomUUID().toString();
        this.out = new ObjectOutputStream(socket.getOutputStream());
        this.in = new ObjectInputStream(socket.getInputStream());

        // Optional: listen for server messages in another thread
        new Thread(this::listenToServer).start();
    }

    public void sendMessage(MessageToSend msg) {
        try {
            msg.setSenderID(clientID);
            out.writeObject(msg);
            out.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void listenToServer() {
        try {
            while (true) {
                Object response = in.readObject();
                System.out.println("Server: " + response);

                if (response instanceof MessageToSend msg) {
                    System.out.println("Received: " + msg);

//                    panel.drawPixel(panel.getCell(msg.col, msg.row), msg.pixel.x, msg.pixel.y ,msg.getPlayerColor());
                    if (msg.getType().equals("Scribble")) {
                        SwingUtilities.invokeLater(() -> {
                            Cell cell = panel.getCell(msg.row, msg.col);
                            if (cell != null) {
                                System.out.println("Cell is not null");
                                cell.setBeingClaimed(true);
                                cell.addDrawnPixel(msg.pixel.x % 50, msg.pixel.y % 50, msg.getPlayerColor());
                                panel.repaint();
                            }
                        });
                    } else if (msg.getType().equals("Release")) {
                        SwingUtilities.invokeLater(() -> {
                            Cell cell = panel.getCell(msg.row, msg.col);
                            if (cell != null) {
                                cell.checkIfValidFill(msg.getPlayerColor());
                                panel.repaint();
                            }
                        });
                    }
                    else if (msg.getType().equals("LockGranted")) {
                        lockGranted = true;
                        synchronized (lockWaiter) {
                            lockWaiter.notify();
                        }
                    } else if (msg.getType().equals("LockDenied")) {
                        lockGranted = false;
                        synchronized (lockWaiter) {
                            lockWaiter.notify();
                        }
                    }
                }

            }
        } catch (IOException | ClassNotFoundException e) {
            System.err.println("Server connection closed or error: " + e.getMessage());
        }
    }

    public boolean requestLockAndWait(int row, int col, Point pixel) {
        lockGranted = false;
        MessageToSend requestMsg = new MessageToSend(row, col, pixel, Color.BLACK, "Request", this.clientID);
        sendMessage(requestMsg);

        synchronized (lockWaiter) {
            try {
                lockWaiter.wait(1000); // wait up to 1 second
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        return lockGranted;
    }


    public void close() {
        try {
            socket.close();
        } catch (IOException e) {
            // Ignore
        }
    }
}


===== src/network/ClientHandler.java =====
package network;

import java.io.*;
import java.net.IDN;
import java.net.Socket;

public class ClientHandler implements Runnable {
    private final Socket socket;
    ObjectInputStream in = null;
    ObjectOutputStream out = null;
    private final Server server;
    private String clientId;

    public ClientHandler(Socket socket, Server server) {
        this.socket = socket;
        this.server = server;
    }

    public void send(Object obj) {
        try {
            if (out != null) {
                out.writeObject(obj);
                out.flush();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void run() {
        try {
            in = new ObjectInputStream(socket.getInputStream());
            out = new ObjectOutputStream(socket.getOutputStream());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        try {
            Object obj;
            while ((obj = in.readObject()) != null) {
                if (obj instanceof MessageToSend message) {
                    System.out.println("Received message: " + message);
                    this.clientId = message.getSenderID();
//                    System.out.println(message.pixel.x + message.pixel.y);
                    out.writeObject("Received your message!");
                    server.broadcast(message);
                }
            }
        } catch (EOFException e) {
            // Client closed connection
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                socket.close();
            } catch (IOException e) {
                // Ignore
            }
            server.remove(this);
            System.out.println("Client disconnected: " + socket.getInetAddress());
        }
    }

    public String getClientID() {
        return clientId;
    }
}


===== src/network/Server.java =====
package network;

import game.*;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
// import java.util.concurrent.CopyOnWriteArrayList;

public class Server {
    private ServerSocket serverSocket;
    private final ArrayList<ClientHandler> clients = new ArrayList<>(); // changed this form something might break
    GameBoard board;

    //cells being claimed list

    public Server() throws IOException {
        serverSocket = new ServerSocket(53333);
        board = new GameBoard();
        System.out.println("Server started on port 53333");
    }

    public void start() throws IOException {
        while (true) {
            Socket socket = serverSocket.accept();
            System.out.println("New client connected: " + socket.getInetAddress());

            ClientHandler handler = new ClientHandler(socket, this);  // Pass server reference if needed
            clients.add(handler);
            new Thread(handler).start();
        }
    }

    public void broadcast(MessageToSend message) {
        if (message.getType().equals("Request")) {
            Cell requestedCell = board.getCellByRowAndCol(message.getRow(), message.getCol());
            if (requestedCell != null && requestedCell.tryLock()) {
                // Lock acquired — send confirmation only to sender
                message.setType("LockGranted");
                sendToClient(message.getSenderID(), message);
            } else {
                // Lock not acquired — deny request
                System.out.println("DENIED: " + message.senderID);
                message.setType("LockDenied");
                sendToClient(message.getSenderID(), message);
            }
            return;
        }
        for (ClientHandler client : clients) {
            client.send(message);
        }
    }

    public void sendToClient(String clientID, MessageToSend msg) {
        for (ClientHandler client : clients) {
            if (client.getClientID().equals(clientID)) {
                client.send(msg);
                break;
            }
        }
    }

    public void remove(ClientHandler client) {
        clients.remove(client);
    }

    public static void main(String[] args) {
        try {
            Server server = new Server();
            server.start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


===== src/game/GameFrame.java =====
package game;

import com.formdev.flatlaf.FlatLightLaf;
import javax.swing.*;
import java.awt.*;
import java.io.IOException;

public class GameFrame extends JFrame {

    public GameFrame() throws IOException {
        // Set up the window
        setTitle("Deny and Conquer");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        // Using FlatLaf for a modern look
        FlatLightLaf.setup();

        // Use a consistent font across all components, optional but recommended
        UIManager.put("Label.font", new Font("SansSerif", Font.PLAIN, 14));
        UIManager.put("Button.font", new Font("SansSerif", Font.PLAIN, 14));
        UIManager.put("MenuItem.font", new Font("SansSerif", Font.PLAIN, 14));

        // Show a color chooser (or a custom color dialog)
        ColorPickerDialog.UserSelection userSelection = ColorPickerDialog.showDialog(this);
        String username = userSelection.getUsername();
        Color selectedColor = userSelection.getColor();

        // Create and add the main game panel
        GamePanel gamePanel = new GamePanel(selectedColor);
        add(gamePanel, BorderLayout.CENTER);

        // Optional: create a menu bar
        setJMenuBar(createMenuBar());

        // Finalize layout
        pack();
        setLocationRelativeTo(null); // center on screen
        setVisible(true);
    }

    private JMenuBar createMenuBar() {
        JMenuBar menuBar = new JMenuBar();
        JMenu gameMenu = new JMenu("Game");

        JMenuItem restartItem = new JMenuItem("Restart");
        restartItem.addActionListener(e -> {
            JOptionPane.showMessageDialog(this,
                    "Restart not implemented in this demo!",
                    "Info",
                    JOptionPane.INFORMATION_MESSAGE);
        });
        gameMenu.add(restartItem);
        menuBar.add(gameMenu);

        return menuBar;
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            try {
                // If you don't want FlatLaf, comment above line & uncomment Nimbus:
                // for (UIManager.LookAndFeelInfo info : UIManager.getInstalledLookAndFeels()) {
                //     if ("Nimbus".equals(info.getName())) {
                //         UIManager.setLookAndFeel(info.getClassName());
                //         break;
                //     }
                // }

                new GameFrame();
            } catch (IOException e) {
                e.printStackTrace();
                JOptionPane.showMessageDialog(null,
                        "Could not connect to server:\n" + e.getMessage(),
                        "Connection Error",
                        JOptionPane.ERROR_MESSAGE);
                System.exit(1);
            }
        });
    }
}


===== src/game/ColorPickerDialog.java =====
package game;

import javax.swing.*;
import java.awt.*;

public class ColorPickerDialog {

    /**
     * Displays a series of dialogs to:
     * 1. Ask for a username.
     * 2. Show the game rules.
     * 3. Allow the user to pick one of five predefined colors.
     *
     * @param parent the parent component for the dialogs.
     * @return A UserSelection object containing the username and chosen color.
     */
    public static UserSelection showDialog(Component parent) {
        // 1. Ask for username
        String username = JOptionPane.showInputDialog(
                parent,
                "Enter your username:",
                "Username",
                JOptionPane.PLAIN_MESSAGE
        );
        if (username == null || username.trim().isEmpty()) {
            username = "Guest";
        }

        // 2. Show the game rules
        String rules = "Game Rules:\n" +
                "1. Claim a cell by drawing within it.\n" +
                "2. Only one cell can be claimed at a time.\n" +
                "3. Use your selected color to mark your territory.\n" +
                "4. The game ends when all cells are claimed.\n" +
                "5. The player with the most claimed cells wins!";
        JOptionPane.showMessageDialog(
                parent,
                rules,
                "Game Rules",
                JOptionPane.INFORMATION_MESSAGE
        );

        // 3. Provide a list of 5 colors to choose from
        String[] colorNames = {"Green", "Red", "Blue", "Orange", "Magenta"};
        Color[] colors = {Color.GREEN, Color.RED, Color.BLUE, Color.ORANGE, Color.MAGENTA};
        String chosenColorName = (String) JOptionPane.showInputDialog(
                parent,
                "Choose Your Player Color:",
                "Color Selection",
                JOptionPane.PLAIN_MESSAGE,
                null,
                colorNames,
                colorNames[0]
        );

        Color chosenColor = Color.GRAY; // default fallback
        for (int i = 0; i < colorNames.length; i++) {
            if (colorNames[i].equals(chosenColorName)) {
                chosenColor = colors[i];
                break;
            }
        }

        return new UserSelection(username, chosenColor);
    }

    /**
     * A simple class to hold the user's selection data.
     */
    public static class UserSelection {
        private final String username;
        private final Color color;

        public UserSelection(String username, Color color) {
            this.username = username;
            this.color = color;
        }

        public String getUsername() {
            return username;
        }

        public Color getColor() {
            return color;
        }
    }
}


===== src/game/GameBoard.java =====
package game;

import java.awt.*;

public class GameBoard {
    private final int rows = 8;
    private final int cols = 8;
    private final Cell[][] gameBoard;
    private final int cellSize = 50;

    public GameBoard() {
        gameBoard = new Cell[rows][cols];
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                gameBoard[row][col] = new Cell(col * 50, row * 50);
            }
        }
    }

    public void drawBoard(Graphics2D g) {
        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < cols; col++) {
                int x = col * cellSize;
                int y = row * cellSize;
                gameBoard[row][col].draw(g, x, y);

            }
        }
    }

    public Cell getCellAtPixel(int x, int y) {
        int col = x / cellSize;
        int row = y / cellSize;

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            return gameBoard[row][col];
        }
        return null;
    }

    public Cell getCellByRowAndCol(int row, int col) {
        return gameBoard[row][col];
    }

//    public boolean allCellsClaimed() {
//        for (Cell[] row : grid) {
//            for (Cell cell : row) {
//                if (!cell.isClaimed()) {
//                    return false;
//                }
//            }
//        }
//        return true;
//    }
//
//    public int countOwnedByColor(Color color) {
//        int count = 0;
//        for (Cell[] row : grid) {
//            for (Cell cell : row) {
//                if (cell.getOwnerColor().equals(color)) {
//                    count++;
//                }
//            }
//        }
//        return count;
//    }
}


===== src/game/GamePanel.java =====
package game;

import network.Client;
import network.MessageToSend;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.IOException;

public class GamePanel extends JPanel implements MouseListener, MouseMotionListener {

    private final GameBoard board;
    private Cell cellBeingDrawnOn = null;
    private Color playerColor;
    MessageToSend lastMsg;
    MessageToSend requestMsg;
    private boolean gameOver = false;
    Client player;

    // Add a modern status panel (for e.g., showing game messages)
    private JLabel statusLabel;

    public GamePanel(Color selectedColor) throws IOException {
        setLayout(new BorderLayout());
        setBackground(new Color(245, 245, 245)); // subtle light background
        this.board = new GameBoard();
        this.player = new Client(this);
        this.playerColor = selectedColor;

        // Create a status panel at the bottom
        statusLabel = new JLabel("Play!", SwingConstants.CENTER);
        statusLabel.setFont(new Font("SansSerif", Font.PLAIN, 14));
        statusLabel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));
        add(statusLabel, BorderLayout.SOUTH);

        // Panel for the drawing board
        GameBoardPanel boardPanel = new GameBoardPanel();
        boardPanel.addMouseListener(this);
        boardPanel.addMouseMotionListener(this);
        add(boardPanel, BorderLayout.CENTER);

        // Set preferred size for the game area
        setPreferredSize(new Dimension(450, 450));
    }

    // Custom inner class to handle board painting
    private class GameBoardPanel extends JPanel {
        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            // Enable anti-aliasing for smooth drawing
            Graphics2D g2 = (Graphics2D) g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
            board.drawBoard(g2);
        }
    }

    @Override
    public void mousePressed(MouseEvent e) {
        if (gameOver) {
            return;
        }
        // Calculate grid coordinates based on modernized board panel size
        int gridSize = 50; // if you decide to make cell size dynamic, calculate here
        int col = e.getX() / gridSize;
        int row = e.getY() / gridSize;
        boolean gotLock = player.requestLockAndWait(row, col, new Point(e.getX(), e.getY()));
        if (!gotLock) {
            statusLabel.setText("Cell lock denied — try another cell.");
            return;
        }
        Cell cell = board.getCellAtPixel(e.getX(), e.getY());
        requestMsg = new MessageToSend(row, col, new Point(e.getX(), e.getY()), Color.BLACK, "Request", "-1");
        player.sendMessage(requestMsg);
        if (cell != null && !cell.isClaimed() && !cell.isBeingClaimed()) {
            cell.setBeingClaimed(true);
            cellBeingDrawnOn = cell;
        }
    }

    @Override
    public void mouseDragged(MouseEvent e) {
        if (gameOver) {
            return;
        }
        drawPixel(cellBeingDrawnOn, e.getX(), e.getY(), playerColor);
    }

    public void drawPixel(Cell cell, int pixelX, int pixelY, Color color) {
        if (cell != null) {
            if (checkIfStillInsideCell(cell, pixelX, pixelY)) {
                int x = pixelX % 50;
                int y = pixelY % 50;
                cell.addDrawnPixel(x, y, color);
                repaint();
                lastMsg = new MessageToSend(pixelX / 50, pixelY / 50, new Point(x, y), color, "Scribble", "-1");
                player.sendMessage(lastMsg);
            }
        }
    }

    private boolean checkIfStillInsideCell(Cell cell, int x, int y) {
        Point startPoint = cell.locOnCanvas;
        return (startPoint.x <= x && x < startPoint.x + 50) &&
                (startPoint.y <= y && y < startPoint.y + 50);
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        if (cellBeingDrawnOn != null) {
            cellBeingDrawnOn.checkIfValidFill(playerColor);
            cellBeingDrawnOn = null;
            repaint();

            MessageToSend mouseReleaseMsg = new MessageToSend(lastMsg.getRow(), lastMsg.getCol(), lastMsg.getPixel(), lastMsg.getPlayerColor(), "Release", "-1");
            player.sendMessage(mouseReleaseMsg);
            String color = checkWinCondition();
            if (color != null) {
                Color winnerColor = getColorFromName(color);
                MessageToSend winMsg = new MessageToSend(-1, -1, new Point(0, 0), winnerColor, "GameOver", "0");
                player.sendMessage(winMsg);
                gameOver = true;
                statusLabel.setText("Game Over! Winner: " + color);
            }
        }
    }

    // Unused MouseListener events:
    public void mouseClicked(MouseEvent e) {}
    public void mouseEntered(MouseEvent e) {}
    public void mouseExited(MouseEvent e) {}
    public void mouseMoved(MouseEvent e) {}

    public Cell getCell(int col, int row) {
        return board.getCellByRowAndCol(row, col);
    }

    public String checkWinCondition() {
        java.util.HashMap<String, Integer> colorCounts = new java.util.HashMap<>();
        for (int row = 0; row < 8; row++) {
            for (int col = 0; col < 8; col++) {
                Cell cell = board.getCellByRowAndCol(row, col);
                Color color = cell.getColorOfCell();
                String colorName = getColorName(color);
                if (colorName.equalsIgnoreCase("WHITE")) {
                    return null;
                }
                colorCounts.put(colorName, colorCounts.getOrDefault(colorName, 0) + 1);
            }
        }
        String winner = null;
        int maxCount = 0;
        for (java.util.Map.Entry<String, Integer> entry : colorCounts.entrySet()) {
            if (entry.getValue() > maxCount) {
                winner = entry.getKey();
                maxCount = entry.getValue();
            }
        }
        return winner;
    }

    private String getColorName(Color color) {
        if (color.equals(Color.RED)) return "RED";
        if (color.equals(Color.BLUE)) return "BLUE";
        if (color.equals(Color.GREEN)) return "GREEN";
        if (color.equals(Color.ORANGE)) return "ORANGE";
        if (color.equals(Color.MAGENTA)) return "MAGENTA";
        if (color.equals(Color.WHITE)) return "WHITE";
        return "UNKNOWN";
    }
    private Color getColorFromName(String name) {
        switch (name.toUpperCase()) {
            case "RED": return Color.RED;
            case "BLUE": return Color.BLUE;
            case "GREEN": return Color.GREEN;
            case "ORANGE": return Color.ORANGE;
            case "MAGENTA": return Color.MAGENTA;
            default: return Color.GRAY;
        }
    }
}


===== src/game/Cell.java =====
package game;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.HashSet;
import java.util.Set;
import java.util.concurrent.locks.ReentrantLock;

public class Cell {
    Color colorOfCell = Color.WHITE;
    boolean isClaimed = false;
    boolean isBeingClaimed = false;
    private final ReentrantLock lock = new ReentrantLock();

    Point locOnCanvas;
    BufferedImage drawing = new BufferedImage(50, 50, BufferedImage.TYPE_INT_ARGB);

    private final Set<Point> pixelSet = new HashSet<>();


    public Cell(int x, int y) {
        locOnCanvas = new Point(x, y);
    }

    public void draw(Graphics g, int x, int y) {
        if (isClaimed) {
            g.setColor(colorOfCell);
            g.fillRect(x, y, 50, 50);
        } else {
            g.setColor(Color.WHITE);
            g.fillRect(x, y, 50, 50);
            g.drawImage(drawing, x, y, null);
        }
        g.setColor(Color.BLACK);
        g.drawRect(x, y, 50, 50);
    }

    public boolean tryLock() {
        return lock.tryLock();
    }

    public void unlock() {
        lock.unlock();
    }

    public boolean isClaimed() {
        return isClaimed;
    }

    public boolean isBeingClaimed() {
        return isBeingClaimed;
    }

    public void setBeingClaimed(boolean flag) {
        isBeingClaimed = flag;
    }

    public void addDrawnPixel(int x, int y, Color playerColor) {
        if (!isClaimed && !isBeingClaimed) return;

        if (!pixelSet.contains(new Point(x, y))) {
            pixelSet.add(new Point(x, y));
            Graphics2D g2d = drawing.createGraphics();
            g2d.setColor(playerColor); // semi-transparent red
            g2d.fillRect(x, y, 2, 2);
            g2d.dispose();
        }
        System.out.println("Pixel Added: (" + x + ", " + y + ")");
    }

    public boolean checkIfValidFill(Color playerColor) {
        boolean flag = false;
        System.out.println("Checking fill — pixelSet size: " + pixelSet.size());

        if (pixelSet.size() >= 125) {
            colorOfCell = playerColor;
            isClaimed = true;
            System.out.println("Cell Valid");
            flag = true;
        } else {
            Graphics2D g2d = drawing.createGraphics();
            g2d.setComposite(AlphaComposite.Clear);
            g2d.fillRect(0, 0, drawing.getWidth(), drawing.getHeight());
            g2d.dispose();
        }

        pixelSet.clear();
        isBeingClaimed = false;
        return flag;
    }

    public Color getColorOfCell(){
        return this.colorOfCell;
    }
}


